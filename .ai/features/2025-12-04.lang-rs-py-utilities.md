# Feature: Language-Specific Utilities for Rust and Python

## Feature Description

Create `utils/lang-rs.sh` and `utils/lang-py.sh` that provide language-specific utility functions for Rust and Python projects, mirroring the functionality provided by `utils/lang-js.sh` for JavaScript/TypeScript projects.

These utilities enable:
- Reading project manifest files (Cargo.toml, pyproject.toml, requirements.txt)
- Checking for dependencies across different sections
- Detecting linters and formatters by dependency or config file
- Identifying package managers
- Filtering packages/crates that are not yet installed

## Files Affected

### New Files
- `utils/lang-rs.sh` - Rust project utilities
- `utils/lang-py.sh` - Python project utilities
- `tests/unit/lang-rs.test.ts` - Tests for Rust utilities
- `tests/unit/lang-py.test.ts` - Tests for Python utilities

### Modified Files
- None (new feature only)

### Existing Related Files (reference only)
- `utils/lang-js.sh` - Pattern to follow
- `utils/detection.sh` - Has `looks_like_rust_project()` and `looks_like_python_project()`
- `tests/unit/lang-js.test.ts` - Test pattern to follow

## Test Scope

```bash
# Test glob patterns
pnpm test tests/unit/lang-rs.test.ts tests/unit/lang-py.test.ts

# Or use glob
pnpm test "tests/unit/lang-{rs,py}.test.ts"
```

## Baseline Test Status

- **Current test files**: 0 (new feature)
- **Pre-existing failures**: N/A

## Implementation Checklist

- [ ] Step 2: Planning (detailed below)
- [ ] Step 3: Unit tests created via tester sub-agent
- [ ] Step 4: Implementation complete
- [ ] Step 5: Review complete

---

## Step 2: Implementation Plan

### Architecture

Both `lang-rs.sh` and `lang-py.sh` follow the same structure as `lang-js.sh`:
1. Source guard to prevent re-execution
2. Path setup for `ROOT` and `UTILS`
3. Manifest file reading functions
4. Dependency checking functions
5. Linter/formatter detection
6. Package manager detection
7. CLI invocation handler

### Rust Utilities (lang-rs.sh)

#### Functions to Implement

| Function | Description |
|----------|-------------|
| `get_cargo_toml()` | Read Cargo.toml from CWD or repo root |
| `has_dependency(dep)` | Check `[dependencies]` section |
| `has_dev_dependency(dep)` | Check `[dev-dependencies]` section |
| `has_build_dependency(dep)` | Check `[build-dependencies]` section |
| `has_dependency_anywhere(dep)` | Check all dependency sections |
| `crates_not_installed(crates...)` | Return crates not in Cargo.toml |
| `get_rs_linter_by_config()` | Detect linter config (clippy.toml, dylint.toml) |
| `get_rs_formatter_by_config()` | Detect formatter config (rustfmt.toml) |
| `is_cargo_workspace()` | Check if `[workspace]` section exists |

#### Linter/Formatter Detection

**Linters:**
- **clippy** - Rust's default linter (implicit, config: `clippy.toml`, `.clippy.toml`)
- **dylint** - Custom lint library (dependency: `dylint`, config: `dylint.toml`)

**Formatters:**
- **rustfmt** - Rust's default formatter (config: `rustfmt.toml`, `.rustfmt.toml`)

Note: Unlike JS where multiple linters compete, Rust has clippy as the standard. Detection is primarily config-based.

#### TOML Parsing Strategy

Use `grep` for simple key existence checks. For more complex parsing, use:
- `tomlq` if available (from `yq`)
- Fallback to `grep` + `awk` patterns

### Python Utilities (lang-py.sh)

#### Functions to Implement

| Function | Description |
|----------|-------------|
| `get_pyproject_toml()` | Read pyproject.toml from CWD or repo root |
| `get_requirements_txt()` | Read requirements.txt from CWD or repo root |
| `has_dependency(dep)` | Check project dependencies |
| `has_dev_dependency(dep)` | Check dev/optional dependencies |
| `has_dependency_anywhere(dep)` | Check all dependency locations |
| `packages_not_installed(pkgs...)` | Return packages not in project files |
| `py_package_manager()` | Detect pip/poetry/pipenv/uv/pdm/hatch/conda |
| `get_py_linter_by_dep()` | Detect linter by dependency |
| `get_py_linter_by_config()` | Detect linter by config file |
| `get_py_formatter_by_dep()` | Detect formatter by dependency |
| `get_py_formatter_by_config()` | Detect formatter by config file |

#### Package Managers

| Manager | Lock File | Config File |
|---------|-----------|-------------|
| pip | requirements.txt | setup.py, setup.cfg |
| poetry | poetry.lock | pyproject.toml (tool.poetry) |
| pipenv | Pipfile.lock | Pipfile |
| uv | uv.lock | pyproject.toml (tool.uv) |
| pdm | pdm.lock | pyproject.toml (tool.pdm) |
| hatch | - | pyproject.toml (tool.hatch) |
| conda | environment.yml | conda.yaml |

#### Linters

| Linter | Package | Config Files |
|--------|---------|--------------|
| ruff | ruff | ruff.toml, .ruff.toml, pyproject.toml [tool.ruff] |
| flake8 | flake8 | .flake8, setup.cfg, tox.ini |
| pylint | pylint | .pylintrc, pylintrc, pyproject.toml [tool.pylint] |
| mypy | mypy | mypy.ini, .mypy.ini, pyproject.toml [tool.mypy] |
| pyright | pyright | pyrightconfig.json, pyproject.toml [tool.pyright] |

Priority: ruff > flake8 > pylint (ruff is modern and fast)

#### Formatters

| Formatter | Package | Config Files |
|-----------|---------|--------------|
| ruff | ruff | (same as linter) |
| black | black | pyproject.toml [tool.black] |
| yapf | yapf | .style.yapf, pyproject.toml [tool.yapf] |
| autopep8 | autopep8 | setup.cfg, tox.ini |
| isort | isort | .isort.cfg, pyproject.toml [tool.isort] |

Priority: ruff > black > yapf > autopep8

#### Dependency Detection Strategy

Python has multiple dependency declaration patterns:

1. **pyproject.toml (PEP 621)**:
   - `project.dependencies` - runtime deps
   - `project.optional-dependencies` - dev/optional deps
   - `tool.poetry.dependencies` - Poetry-specific
   - `tool.poetry.dev-dependencies` - Poetry dev deps

2. **requirements.txt**:
   - Simple line-by-line format
   - May have `requirements-dev.txt`, `requirements-test.txt`

3. **setup.py/setup.cfg**:
   - `install_requires` - runtime deps
   - `extras_require` - optional deps

Strategy: Check pyproject.toml first, then requirements.txt, then setup files.

### Edge Cases

1. **TOML Parsing**: Without a proper TOML parser, use regex patterns carefully
2. **Inline dependencies**: Handle both `dep = "1.0"` and `dep = { version = "1.0" }` formats
3. **Workspace members**: For monorepos, check workspace root first
4. **Virtual environments**: Don't confuse with installed packages (check project files only)
5. **Comment handling**: Ignore commented-out dependencies

### Dependencies

- Uses existing: `detection.sh`, `logging.sh`, `filesystem.sh`, `text.sh`
- Optional: `tomlq`/`yq` for better TOML parsing
- Fallback: Pure bash with `grep`/`awk`

---

## Notes

- Both utilities should be usable standalone (CLI mode) and sourceable
- Follow the same code conventions as `lang-js.sh`
- All functions should be tested in both bash and zsh where possible
