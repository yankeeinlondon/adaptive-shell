# Feature: PVE Node Identification

**Date:** 2025-12-01
**Feature Name:** pve-node-identification

## Feature Description

Implement the PVE node identification system that discovers and caches Proxmox VE cluster information. This feature enables:

1. **Node Discovery** - Find a reachable PVE node from various sources (explicit request, known clusters, defaults)
2. **Cluster Caching** - Save discovered cluster info to `~/.pve-cluster.env` for faster future lookups
3. **Connectivity Testing** - Verify nodes are actually reachable before using them

The system follows this flow:
```
get_proxmox_node([requested])
    ├── Load CLUSTER_ENV_FILE if exists
    ├── match_known_cluster(requested) → returns candidate nodes from ENV
    ├── pve_node_up(candidates) → tests connectivity, returns first reachable
    └── save_pve_cluster(node) → saves cluster info for future use
            └── get_pve_cluster() → queries API for cluster info
```

### CLUSTER_ENV_FILE Format

The file `~/.pve-cluster.env` uses this format:
```bash
PVE_CLUSTER_VENICE="192.168.100.2 192.168.100.4 192.168.100.5"
PVE_CLUSTER_ROME="192.168.200.1 192.168.200.2"
DEFAULT_PVE_CLUSTER="VENICE"
```

## Files Affected

### Modified
- `utils/proxmox.sh` - Implement/fix the five target functions

### Dependencies (read-only, for context)
- `utils/logging.sh` - `logc`, `debug`, `error` functions
- `utils/detection.sh` - `is_pve_host`, `is_lxc`, `is_vm` functions
- `utils/network.sh` - `is_ip4_address`, `is_ip6_address`, `is_dns_name` functions
- `utils/filesystem.sh` - `file_exists` functions
- `utils/text.sh` - `uc` (uppercase), `is_empty`, `not_empty` functions

## Test Scope

**Glob Pattern:** `tests/**/proxmox*.test.ts`

**Test Command:**
```bash
pnpm test tests/proxmox-node.test.ts
```

## Baseline Test Status

No existing tests for these specific functions. This is a new test file.

- Total tests in scope: 0 (new)
- Passing: N/A
- Failing: N/A

## Implementation Checklist

- [x] Step 2: Planning complete
- [x] Step 3: Unit tests created
- [x] Step 4: Implementation complete
- [ ] Step 5: Review complete

---

## Architecture

### Functions to Implement/Fix

#### 1. `pve_node_up(candidates_ref)`
**Purpose:** Test connectivity to candidate nodes, return first reachable one.

**Input:** Nameref to array of candidate addresses (IPs or hostnames)
**Output:** First reachable node address, or empty string if none found

**Logic:**
```bash
for candidate in "${candidates[@]}"; do
    if curl -sk --max-time 2 --connect-timeout 2 "https://$candidate:${PVE_API_PORT}/" &>/dev/null; then
        echo "$candidate"
        return 0
    fi
done
echo ""
return 1
```

#### 2. `match_known_cluster(requested)`
**Purpose:** Look up known cluster configurations from ENV variables.

**Input:** Optional cluster name request (can be empty)
**Output:** Space-delimited IP addresses for the matched cluster

**Logic:**
1. If `requested` is empty:
   - If `DEFAULT_PVE_CLUSTER` is set, use that as the cluster name
   - Otherwise return empty
2. If `requested` is provided:
   - Uppercase it and look for `PVE_CLUSTER_{UPPERCASE_NAME}`
3. Return the value of the matched ENV variable (space-delimited IPs)

#### 3. `save_pve_cluster(node)`
**Purpose:** Query cluster info from a validated node and save to disk.

**Input:** A validated, reachable PVE node address
**Output:** None (writes to CLUSTER_ENV_FILE)

**Logic:**
1. Call `get_pve_cluster()` to get cluster status JSON
2. Parse cluster name from JSON
3. Parse node IPs from JSON
4. Write/update CLUSTER_ENV_FILE with:
   - `PVE_CLUSTER_{NAME}="ip1 ip2 ip3"`
   - `DEFAULT_PVE_CLUSTER="{NAME}"` (if not already set or if only one cluster)

#### 4. `get_proxmox_node([requested])` - Bug Fixes
**Purpose:** Orchestrate node discovery.

**Fixes needed:**
- Line 232: Change `$#candidates` to `${#candidates[@]}`
- Line 252: Change `elif` to `else`
- Line 231: Handle empty return from `match_known_cluster` properly

#### 5. `get_pve_cluster()` - Already Implemented
Returns JSON from `/cluster/status` API endpoint.

### Edge Cases

1. **No CLUSTER_ENV_FILE exists** - Should fall through to default candidates
2. **All candidates unreachable** - Return appropriate error
3. **Malformed CLUSTER_ENV_FILE** - Should not crash, fall through to defaults
4. **First-time discovery** - Creates CLUSTER_ENV_FILE from scratch
5. **Multiple clusters** - Should preserve existing entries when adding new one
6. **Single cluster** - AUTO set as DEFAULT_PVE_CLUSTER

### Dependencies

No new dependencies required. Uses existing utilities:
- `curl` for connectivity testing (already a prereq)
- `jq` for JSON parsing (already a prereq)

**Note:** The `uc()` function (uppercase) is referenced in `match_known_cluster()` but doesn't exist. Need to add it to `utils/text.sh` alongside the existing `lc()` function.

---

## Implementation Steps

### Step 1: Add `uc()` function to `utils/text.sh`

Add uppercase conversion function (mirrors existing `lc()` function):

```bash
# uc <string>
#
# converts the passed in <string> to uppercase
function uc() {
    local -r str="${*}"
    debug "uc(${str})" "$(echo "${str}" | tr '[:lower:]' '[:upper:]')"
    echo "${str}" | tr '[:lower:]' '[:upper:]'
}
```

### Step 2: Implement `pve_node_up()`

Replace the TODO stub with working implementation:

```bash
# pve_node_up <ref:candidates>
#
# Receives a reference to an array of candidate nodes and returns
# the first URL which is actively listening on the expected API port.
#
# If no candidates are found to be a valid API endpoint then
# an empty string is returned and exit code 1.
function pve_node_up() {
    local -n __candidates=$1

    for candidate in "${__candidates[@]}"; do
        if curl -sk --max-time 2 --connect-timeout 2 \
            "https://${candidate}:${PVE_API_PORT}/" &>/dev/null; then
            echo "$candidate"
            return ${EXIT_OK}
        fi
    done

    echo ""
    return 1
}
```

### Step 3: Implement `match_known_cluster()`

Complete the logic for looking up known clusters:

```bash
# match_known_cluster [requested]
#
# Looks up known cluster configurations from ENV variables.
# Returns space-delimited IP addresses for the matched cluster.
#
# Logic:
#   1. If requested is provided, look for PVE_CLUSTER_{UPPERCASE_REQUESTED}
#   2. If requested is empty but DEFAULT_PVE_CLUSTER is set, use that
#   3. Returns the value (space-delimited IPs) or empty string
function match_known_cluster() {
    local -r requested="${1:-}"
    local cluster_name
    local var_name

    if is_empty "${requested}"; then
        if is_empty "${DEFAULT_PVE_CLUSTER:-}"; then
            # No requested cluster, no default - return empty
            echo ""
            return 1
        else
            cluster_name="${DEFAULT_PVE_CLUSTER}"
        fi
    else
        cluster_name="$(uc "${requested}")"
    fi

    var_name="PVE_CLUSTER_${cluster_name}"

    # Use indirect expansion to get the variable value
    if [[ -n "${!var_name:-}" ]]; then
        echo "${!var_name}"
        return 0
    fi

    echo ""
    return 1
}
```

### Step 4: Implement `save_pve_cluster()`

Save cluster info to disk for future lookups:

```bash
# save_pve_cluster <node>
#
# Takes a validated PVE node and queries the cluster
# information, then saves it to ${CLUSTER_ENV_FILE}
# for faster future lookups.
function save_pve_cluster() {
    local -r node="${1}"

    if is_empty "${node}"; then
        return 1
    fi

    local cluster_json
    cluster_json="$(get_pve_cluster)"

    if is_empty "${cluster_json}"; then
        debug "save_pve_cluster" "No cluster info returned from API"
        return 1
    fi

    # Parse cluster name
    local cluster_name
    cluster_name="$(echo "${cluster_json}" | jq -r '.[] | select(.type == "cluster") | .name' 2>/dev/null)"

    if is_empty "${cluster_name}"; then
        debug "save_pve_cluster" "Could not parse cluster name from response"
        return 1
    fi

    # Parse node IPs (nodes have type "node" and ip field)
    local node_ips
    node_ips="$(echo "${cluster_json}" | jq -r '[.[] | select(.type == "node") | .ip] | join(" ")' 2>/dev/null)"

    if is_empty "${node_ips}"; then
        # Fallback: use the node we connected to
        node_ips="${node}"
    fi

    # Uppercase cluster name for variable
    local var_name
    var_name="PVE_CLUSTER_$(uc "${cluster_name}")"

    # Create or update the cluster env file
    if file_exists "${CLUSTER_ENV_FILE}"; then
        # Check if this cluster already exists
        if grep -q "^${var_name}=" "${CLUSTER_ENV_FILE}" 2>/dev/null; then
            # Update existing entry
            sed -i.bak "s|^${var_name}=.*|${var_name}=\"${node_ips}\"|" "${CLUSTER_ENV_FILE}"
            rm -f "${CLUSTER_ENV_FILE}.bak"
        else
            # Append new cluster
            echo "${var_name}=\"${node_ips}\"" >> "${CLUSTER_ENV_FILE}"
        fi

        # Update DEFAULT_PVE_CLUSTER if not set or if only one cluster
        local cluster_count
        cluster_count="$(grep -c '^PVE_CLUSTER_' "${CLUSTER_ENV_FILE}" 2>/dev/null || echo "0")"

        if ! grep -q '^DEFAULT_PVE_CLUSTER=' "${CLUSTER_ENV_FILE}" 2>/dev/null; then
            echo "DEFAULT_PVE_CLUSTER=\"$(uc "${cluster_name}")\"" >> "${CLUSTER_ENV_FILE}"
        elif [[ "${cluster_count}" -eq 1 ]]; then
            sed -i.bak "s|^DEFAULT_PVE_CLUSTER=.*|DEFAULT_PVE_CLUSTER=\"$(uc "${cluster_name}")\"|" "${CLUSTER_ENV_FILE}"
            rm -f "${CLUSTER_ENV_FILE}.bak"
        fi
    else
        # Create new file
        {
            echo "# PVE Cluster Configuration"
            echo "# Auto-generated by adaptive shell scripts"
            echo ""
            echo "${var_name}=\"${node_ips}\""
            echo "DEFAULT_PVE_CLUSTER=\"$(uc "${cluster_name}")\""
        } > "${CLUSTER_ENV_FILE}"
    fi

    debug "save_pve_cluster" "Saved cluster ${cluster_name} with nodes: ${node_ips}"
    return 0
}
```

### Step 5: Fix bugs in `get_proxmox_node()`

1. **Line 232**: Fix array length syntax `$#candidates` → `${#candidates[@]}`
2. **Line 252**: Change `elif` → `else`
3. **Line 231**: Handle empty return from `match_known_cluster()` properly

```bash
# Around line 231-233, change:
candidates=( "$(match_known_cluster "${requested}")" )
if [[ "$#candidates" > 0 ]]; then

# To:
local matched_nodes
matched_nodes="$(match_known_cluster "${requested}")"
if not_empty "${matched_nodes}"; then
    # Split space-delimited string into array
    read -ra candidates <<< "${matched_nodes}"
    node=$(pve_node_up candidates)
elif is_ip4_address "${requested}"; then
    # ... rest stays the same
```

And change line 252 from `elif` to `else`.
