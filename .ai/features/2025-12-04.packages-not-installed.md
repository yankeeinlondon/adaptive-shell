# Feature: packages-not-installed

## Feature Description

Implement the `packages_not_installed()` function in `utils/lang-js.sh`. This function receives a list of npm package names and returns only those which are NOT already installed in the project's `package.json` (checking all dependency sections: dependencies, devDependencies, and peerDependencies).

**Use Case:** This function is useful when you want to determine which packages from a given list need to be installed. For example, a linter setup script might want to install `eslint`, `eslint-config-prettier`, and `prettier` - but only if they're not already present.

**Key Requirements:**
- Accept package names either by reference (bash array name) or by value (as arguments)
- Check against ALL dependency sections (dependencies, devDependencies, peerDependencies)
- Return only the packages that are NOT found in any section
- Handle edge cases: empty input, no package.json, packages with scoped names (@org/pkg)

## Files Affected

**Modified:**
- `utils/lang-js.sh` - Implement the `packages_not_installed()` function (lines 257-260)

**Test Files:**
- `tests/unit/lang-js.test.ts` - Add tests for the new function

## Test Scope

**Glob Pattern:** `tests/unit/lang-js.test.ts`

**Test Command:**
```bash
pnpm test tests/unit/lang-js.test.ts
```

## Baseline Test Status

- **Total tests in scope:** 37
- **Passing:** 37
- **Failing:** 0
- **Pre-existing failures:** None

## Implementation Checklist

- [x] Step 1: Preparation (this file)
- [x] Step 2: Planning
- [x] Step 3: Unit Tests (via tester sub-agent)
- [x] Step 4: Implementation
- [x] Step 5: Review

---

## Planning

### Architecture

The function needs to:
1. Accept packages either as positional arguments OR as a bash array by reference
2. Use `has_dependency_anywhere()` (which already exists) to check each package
3. Output packages that return `1` (not found) from `has_dependency_anywhere()`

### Implementation Steps

1. Parse arguments - detect if first arg is an array reference or direct values
2. Iterate through each package name
3. For each package, call `has_dependency_anywhere "$pkg"`
4. If it returns non-zero (not found), add to output list
5. Echo the list of not-installed packages (newline-separated for easy processing)

### Type Definitions

N/A - Bash script

### Edge Cases

1. **Empty input** - Return empty, exit 0
2. **No package.json** - All packages should be returned as "not installed" (or error?)
3. **Scoped packages** - `@org/package-name` must work (already supported by `has_dependency_anywhere`)
4. **Mixed results** - Some installed, some not - return only the not-installed ones
5. **By-reference array** - Support passing bash array name for efficiency with large lists
6. **All installed** - Return empty, exit 0
7. **None installed** - Return all input packages

### Pass-by-Reference Design

In bash, passing arrays by reference is done by passing the array name as a string and using indirect expansion:

```bash
# Called as: packages_not_installed my_array
# Where my_array=("pkg1" "pkg2" "pkg3")
function packages_not_installed() {
    local first_arg="$1"
    local packages=()

    # Check if first arg is an array name (nameref approach)
    if [[ $# -eq 1 ]] && declare -p "$first_arg" 2>/dev/null | grep -q 'declare -a'; then
        # It's an array reference - use nameref
        local -n arr_ref="$first_arg"
        packages=("${arr_ref[@]}")
    else
        # Direct arguments
        packages=("$@")
    fi

    # ... rest of implementation
}
```

### Dependencies

- Relies on `has_dependency_anywhere()` which is already implemented
- Requires `jq` to be installed (handled by `has_dependency_anywhere`)

---

## Test Details

**Tests Added:** 15 tests in `tests/unit/lang-js.test.ts`

**Test Categories:**
1. Basic functionality (3 tests) - core filtering behavior
2. Dependency section coverage (4 tests) - validates all three sections
3. Input handling (4 tests) - single, multiple, by-ref, empty
4. Edge cases (3 tests) - scoped packages, missing package.json, no dep sections
5. Output format (1 test) - order preservation

**Final Test Status:**
- Total tests in file: 52
- All passing

---

## Review Findings

### Code Quality: PASS
- Clear documentation with usage examples
- Follows project conventions (lowercase_underscores, `local` variables)
- Good comments explaining the nameref detection logic

### Reusability: PASS
- Leverages existing `has_dependency_anywhere()` - no code duplication
- No unnecessary abstractions

### Error Handling: PASS
- Empty input handled gracefully (returns empty, exit 0)
- Relies on `has_dependency_anywhere` for package.json error handling
- Always returns 0 which is appropriate for a filter function

### Security: PASS
- Proper quoting prevents command injection
- No external input executed directly

### Performance: ACCEPTABLE
- Each package requires a `jq` call via `has_dependency_anywhere`
- Could be optimized with single jq query for large lists, but adds complexity
- Acceptable for typical use cases (5-20 packages)

### Compatibility Note
- Uses `local -n` (nameref) which requires Bash 4.3+
- Consistent with existing codebase patterns (utils/cli.sh, utils/typeof.sh, etc.)

### Recommendations: None
Implementation is minimal and focused. No changes recommended.

---

## Bug Fix (Post-Review)

**Issue:** Pass-by-reference was not modifying the array in-place. It was reading the array but still outputting to stdout, defeating the purpose of pass-by-reference.

**Fix:** When passed an array name:
- Now modifies the array IN-PLACE to contain only not-installed packages
- No stdout output (the modified array IS the result)

**Usage in `programs/initialize.sh`:**
```bash
local -a _dev=("vitest" "bumpp" ...)
packages_not_installed _dev       # Filters _dev in-place
if [[ "${#_dev[@]}" -gt 0 ]]; then
    "${pkg}" install "${_dev[*]}"
fi
```
