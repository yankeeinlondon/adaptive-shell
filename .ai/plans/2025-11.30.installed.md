# Implementation Plan - `installed` Function

This plan outlines the implementation of the `installed` function and its supporting package-manager-specific functions in `utils/install.sh`. The goal is to list installed packages from various managers, support filtering (OR logic), and provide clickable links to package details.

## 1. Helper Function: `_filter_and_link`

To reduce duplication and ensure consistent behavior, we will create a helper function that processes a stream of package names.

**Signature:**
`_filter_and_link <manager_label> <url_prefix> <url_suffix> [filters...]`

**Logic:**
1.  **Input:** Reads package names from standard input (one per line).
2.  **Filtering:**
    *   If `[filters...]` are provided, it constructs a `grep` extended regex pattern (`p1|p2|...`).
    *   Filters the input stream using `grep -i -E` (case-insensitive) if filters exist.
3.  **Formatting & Linking:**
    *   Iterates through the (filtered) package names.
    *   Constructs the info URL: `${url_prefix}${pkg_name}${url_suffix}`.
    *   Uses the `link` function (from `utils/link.sh` - assumed sourced or available) to create a clickable ANSI sequence.
    *   Prints `[<manager_label>] <linked_package_name>`.

## 2. Package Manager Functions

We will implement the following functions. Each will check if the package manager command exists, run the command to list packages (names only), and pipe the output to `_filter_and_link`.

| Function | Manager | List Command | URL Pattern |
| :--- | :--- | :--- | :--- |
| `installed_brew` | Homebrew | `brew list --formula -1` | `https://formulae.brew.sh/formula/<name>` |
| `installed_cask` | Homebrew Cask | `brew list --cask -1` | `https://formulae.brew.sh/cask/<name>` |
| `installed_cargo` | Cargo | `cargo install --list` \| `grep -E '^[a-z0-9_-]+ v'` \| `cut -d' ' -f1` | `https://crates.io/crates/<name>` |
| `installed_npm` | NPM (Global) | `npm list -g --depth=0 --json` \| (parse json with node/python or grep/sed fallback?) <br> *Fallback:* `npm list -g --depth=0` \| `grep -oE ' [a-zA-Z0-9@/_-]+@'` \| `sed 's/.$//'` | `https://www.npmjs.com/package/<name>` |
| `installed_pip` | Pip | `pip list --format=json` \| (parse) <br> *Fallback:* `pip list` \| `tail -n +3` \| `awk '{print $1}'` | `https://pypi.org/project/<name>/` |
| `installed_gem` | Ruby Gems | `gem list` \| `cut -d' ' -f1` | `https://rubygems.org/gems/<name>` |
| `installed_apt` | Apt (Debian/Ubuntu) | `apt list --installed 2>/dev/null` \| `cut -d/ -f1` \| `grep -v "Listing..."` | `https://packages.debian.org/search?keywords=<name>` |
| `installed_apk` | Apk (Alpine) | `apk info` | `https://pkgs.alpinelinux.org/packages?name=<name>` |
| `installed_pacman` | Pacman (Arch) | `pacman -Qq` | `https://archlinux.org/packages/?q=<name>` |
| `installed_dnf` | DNF (Fedora) | `dnf list installed` \| `awk '{print $1}'` \| `cut -d. -f1` | `https://packages.fedoraproject.org/pkgs/` (Search UI: `https://apps.fedoraproject.org/packages/s/<name>`) |
| `installed_nix` | Nix | `nix-env -q` | `https://search.nixos.org/packages?channel=unstable&query=<name>` |

**Notes:**
*   **Safety:** Each function will check `has_command <cmd>` before execution.
*   **Parsing:** Commands like `npm` and `cargo` might need careful parsing to get just the names. We will use simple `grep`/`awk`/`cut` pipelines to avoid dependencies on `jq`.

## 3. Main `installed` Function

**Signature:**
`installed [filters...]`

**Logic:**
1.  Accepts optional `filters`.
2.  Iterates through a list of known package manager functions (e.g., `installed_brew`, `installed_cargo`, `installed_npm`, etc.).
3.  Calls each function, passing the `${filters[@]}` down.
4.  Each specific function handles the check for the tool's existence, so `installed` can just call them all sequentially.

## 4. Testing Plan (`tests/install.test.ts`)

We will add new test suites to `tests/install.test.ts`.

**Tests:**
1.  **`_filter_and_link` Logic:**
    *   Test with no filters (passes all).
    *   Test with single filter.
    *   Test with multiple filters (OR logic).
    *   Verify output format (brackets and links).
2.  **Manager Functions (Integration-ish):**
    *   Since we can't run real `brew` or `cargo` in unit tests, we will use the existing mocking framework (`runWithMocks`).
    *   Mock `has_command` to return true for specific tools.
    *   Mock the *execution* of the list command to return a static string of packages.
    *   Verify the output of `installed_<manager>` matches expected filtered/linked output.
3.  **Main `installed` Function:**
    *   Mock multiple managers.
    *   Verify it aggregates output from all of them.

## 5. Implementation Steps

1.  **Modify `utils/install.sh`**:
    *   Add `_filter_and_link`.
    *   Implement specific manager functions.
    *   Implement `installed`.
2.  **Modify `tests/install.test.ts`**:
    *   Add tests for the new functionality.
3.  **Verification**:
    *   Run `pnpm test tests/install.test.ts` to ensure correctness.
