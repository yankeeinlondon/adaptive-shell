# Code Review: Proxmox API/CLI Architecture

**Date:** 2025-12-01
**Scope:** `utils/proxmox-utils.sh`, `utils/proxmox-api.sh`, `utils/proxmox-other.sh`

## Overview

The overall design pattern—abstracting API vs CLI calls behind `pve_endpoint()`—is sound. The architecture correctly identifies that Proxmox operations can be performed via the `pvesh` CLI when running directly on a PVE node, or via REST API when running remotely. However, there are several critical bugs and inconsistencies that need attention before this is production-ready.

---

## Must Fix

### 1. Infinite Recursion in `validate_api_key()`

**File:** `utils/proxmox-utils.sh:118-129`

```bash
function validate_api_key() {
    local -r key="${1:?no URL was passed to fetch_get()}"
    local -r code=$(validate_api_key "${key}")  # ← INFINITE RECURSION
```

The function calls itself, causing a stack overflow. It should call a curl command to validate the key.

**Suggested fix:**

```bash
function validate_api_key() {
    local -r key="${1:?no API key was passed to validate_api_key()}"
    local -r host="$(get_proxmox_node "")"
    local -r url="https://${host}:${PVE_API_PORT}${PVE_API_BASE}version"

    local code
    code=$(curl -sk -o /dev/null -w "%{http_code}" \
        -H "Authorization: PVEAPIToken=${key}" \
        "${url}" 2>/dev/null)

    if [[ "$code" == "200" ]]; then
        debug "validate_api_key" "key was valid"
        return 0
    else
        debug "validate_api_key" "invalid key [${code}]"
        return 1
    fi
}
```

---

### 2. Inverted API/CLI Logic in `pve_endpoint()`

**File:** `utils/proxmox-utils.sh:104-110`

The logic is backwards. When running on a PVE host, you should use `pve_cli_call`, not `pve_api_call`:

```bash
    if is_pve_host; then
        debug "pve_endpoint" "using CLI to get '${path}' with filter '${sanitized}'"
        printf "%s" "$(pve_api_call "${path}" "$sanitized")"  # ← WRONG
    else
        debug "pve_endpoint" "using API to get '${path}' with filter '${sanitized}'"
        printf "%s" "$(pve_cli_call "${path}" "$sanitized")"  # ← WRONG
    fi
```

**Fix:** Swap the function calls to match the diagram and debug messages.

---

### 3. Undefined Variable and Wrong Function in `pve_api_call()`

**File:** `utils/proxmox-utils.sh:399-403`

```bash
    local -r url="$(pve_request_url "${api_path}")"
    local -r host="$(get_pve_node "${suggested_host}")"  # ← Function doesn't exist
    # ...
    result=$(curl -sk --max-time 10 \
        -H "Authorization: PVEAPIToken=${PVE_API_TOKEN}" \
        "https://${host}:${PROXMOX_API_PORT}${fq_path}" 2>/dev/null  # ← $fq_path undefined
```

Issues:

- `get_pve_node` is called but the function is named `get_proxmox_node`
- `$fq_path` is undefined—should use `$url` or construct the path
- `PROXMOX_API_PORT` used instead of `PVE_API_PORT`

---

### 4. Broken Filter Syntax in `pve_node_log()`

**File:** `utils/proxmox-api.sh:244`

```bash
        filter="| map(select(.node == '${}'))"  # ← Empty interpolation
```

Should be:

```bash
        filter="| map(select(.node == '${node}'))"
```

---

### 5. Incorrect `$?` Check in `pve_cli_call()`

**File:** `utils/proxmox-utils.sh:424-427`

```bash
    response="$(eval "$request")"
    debug "pve_cli_call" "got a response from CLI of ${#response} characters"

    # shellcheck disable=SC2181
    if [[ $? -ne 0 ]] || is_empty "$1"; then  # ← $? is from debug, not eval; $1 is wrong
```

The `$?` now reflects the `debug` call, not `eval`. Also `is_empty "$1"` should be `is_empty "$response"`.

**Fix:**

```bash
    local exit_code
    response="$(eval "$request")"
    exit_code=$?
    debug "pve_cli_call" "got a response from CLI of ${#response} characters"

    if [[ $exit_code -ne 0 ]] || is_empty "$response"; then
```

---

## Suggested Improvements

### 1. Inconsistent Error Messages

**Files:** `utils/proxmox-utils.sh:119, 132`

Both functions have incorrect error messages copied from elsewhere:

```bash
function validate_api_key() {
    local -r key="${1:?no URL was passed to fetch_get()}"  # Wrong message

function set_default_token() {
    local -r token="${1:?no URL was passed to fetch_get()}"  # Wrong message
```

Fix the messages to match the function context.

---

### 2. Missing Source Guard in `proxmox-other.sh`

Unlike the other two files, `proxmox-other.sh` lacks a source guard and proper path setup. If this file is to be kept, add:

```bash
[[ -n "${__PROXMOX_OTHER_SH_LOADED:-}" ]] && return
__PROXMOX_OTHER_SH_LOADED=1
```

---

### 3. Duplicate Function Definitions

The following functions exist in multiple files:

- `pve_version`: `proxmox-api.sh:222` and `proxmox-other.sh:7`
- `pve_vm_containers`: `proxmox-api.sh:161` and `proxmox-other.sh:128`
- `pve_storage`: `proxmox-api.sh:172` and `proxmox-other.sh:141`

If `proxmox-other.sh` is legacy code, consider marking it clearly or removing the duplicates to avoid confusion.

---

### 4. Filter Handling Logic in `pve_endpoint()`

**File:** `utils/proxmox-utils.sh:96-101`

The filter manipulation logic is confusing:

```bash
    if [[ "${filter}" != "none"  ]]; then
        if starts_with "$filter" "."; then
            sanitized="${sanitized}$(strip_leading "$filter" ".")"  # Strips "." but $sanitized already has "."
        else
            sanitized="${sanitized} ${filter}"
        fi
    fi
```

This appends `.data.field` for API but for filters starting with `.`, it creates `.data field` (without proper joining). Consider clarifying the intent with comments or refactoring.

---

### 5. Unused `suggested_host` Parameter Flow

In `pve_api_call()`, the `suggested_host` parameter is captured but `pve_request_url()` doesn't use it:

```bash
function pve_api_call() {
    local -r suggested_host="${3}"
    local -r url="$(pve_request_url "${api_path}")"  # ← Doesn't pass suggested_host
```

The `pve_request_url()` calls `get_proxmox_node("")` internally with empty string, ignoring any suggestion. Consider threading the suggestion through consistently.

---

### 6. Consider Consolidating Exit Codes

Exit codes are defined in `proxmox-utils.sh` but may be useful across files:

```bash
EXIT_OK=0
EXIT_CONFIG=1
EXIT_API=2
EXIT_MISSING_PREREQ=3
EXIT_JQ_PARSING=4
EXIT_INVALID_NODE=5
```

Consider moving these to a shared constants file or ensuring they're exported for use by calling scripts.

---

## Nits

### 1. Debug Message Inconsistency

**File:** `utils/proxmox-utils.sh:105, 108`

Debug messages say "using CLI" and "using API" but the actual calls are swapped. Even after fixing the main bug, ensure debug messages match reality.

---

### 2. Trailing Newlines

`proxmox-api.sh` has 2 blank lines at the end (lines 282-283). Minor but inconsistent with other files.

---

### 3. Variable Naming Convention

Some functions use `__` prefix for nameref variables (`__candidates`, `__json`), but not consistently. Consider standardizing.

---

## Positive Observations

1. **Source guards** are properly implemented in both main files, preventing double-sourcing.

2. **Fallback node resolution** in `get_proxmox_node()` (lines 292-346) is well-designed with multiple fallback strategies (known clusters → IP → DNS → defaults).

3. **Cluster caching** via `save_pve_cluster()` is a nice optimization that reduces repeated API lookups.

4. **CLI invocation handlers** at the end of each file (allowing `./proxmox-utils.sh function_name args`) provide good developer ergonomics.

5. **Prerequisite checking** with user prompts for installing `jq`/`curl` is user-friendly.

6. **The `json_list_data()` function** in `proxmox-api.sh` is a clever approach to converting JSON arrays to bash associative arrays, handling the inherent awkwardness of bash's data structures.

---

## Summary

The architecture is fundamentally sound, but there are 5 blocking bugs that need fixing before this code is usable:

1. Infinite recursion in `validate_api_key()`
2. Inverted API/CLI dispatch logic
3. Undefined variables in `pve_api_call()`
4. Empty variable interpolation in `pve_node_log()`
5. Broken exit code check in `pve_cli_call()`

Once these are addressed, the suggested improvements can be tackled to improve maintainability.
