# Code Review: detection.test.ts Test Suite

**Date**: 2025-12-01
**Reviewer**: Claude
**File**: `tests/detection.test.ts`
**Scope**: Comprehensive review of test reliability, external state dependencies, and cross-platform/cross-shell compatibility

---

## Executive Summary

The `detection.test.ts` test suite contains **several tests that depend on external state** rather than controlled test fixtures. This makes tests non-deterministic, potentially flaky across different environments, and fundamentally unreliable for CI/CD pipelines. The most egregious issue is the `repo_is_dirty()` tests which depend on the current git state of the repository being tested.

---

## Must Fix

### 1. `repo_is_dirty()` tests depend on actual repo state (lines 568-595)

**Problem**: These tests assert the current repository's dirty state without creating a controlled test environment:

```typescript
it('should detect modified files in current repo', () => {
  // According to gitStatus, this repo has modified files
  const api = sourceScript('./utils/detection.sh')('repo_is_dirty')(process.cwd())
  expect(api).toBeSuccessful()  // ASSUMES repo is dirty!
})
```

**Why this matters**:
- The test passes only when the repo has uncommitted changes
- On a clean checkout (CI/CD), this test FAILS
- The comment even acknowledges this anti-pattern: "According to gitStatus, this repo has modified files"

**Recommended fix**: Create an isolated git repository for testing:

```typescript
describe('repo_is_dirty()', () => {
  const testGitDir = join(testDir, 'test-git-repo')

  beforeEach(() => {
    // Create a fresh git repo for each test
    mkdirSync(testGitDir, { recursive: true })
    execSync('git init', { cwd: testGitDir })
    execSync('git config user.email "test@test.com"', { cwd: testGitDir })
    execSync('git config user.name "Test"', { cwd: testGitDir })
  })

  it('should return 0 (success) when repo has uncommitted changes', () => {
    // Create and commit a file, then modify it
    writeFileSync(join(testGitDir, 'file.txt'), 'initial')
    execSync('git add . && git commit -m "initial"', { cwd: testGitDir })
    writeFileSync(join(testGitDir, 'file.txt'), 'modified')

    const api = sourceScript('./utils/detection.sh')('repo_is_dirty')(testGitDir)
    expect(api).toBeSuccessful()
  })

  it('should return 1 (failure) when repo is clean', () => {
    // Create and commit a file, leave it clean
    writeFileSync(join(testGitDir, 'file.txt'), 'content')
    execSync('git add . && git commit -m "initial"', { cwd: testGitDir })

    const api = sourceScript('./utils/detection.sh')('repo_is_dirty')(testGitDir)
    expect(api).toFail()
  })

  it('should return 0 for staged but uncommitted changes', () => {
    writeFileSync(join(testGitDir, 'file.txt'), 'initial')
    execSync('git add . && git commit -m "initial"', { cwd: testGitDir })
    writeFileSync(join(testGitDir, 'new.txt'), 'new file')
    execSync('git add new.txt', { cwd: testGitDir })

    const api = sourceScript('./utils/detection.sh')('repo_is_dirty')(testGitDir)
    expect(api).toBeSuccessful()
  })

  it('should return 0 for untracked files', () => {
    writeFileSync(join(testGitDir, 'file.txt'), 'initial')
    execSync('git add . && git commit -m "initial"', { cwd: testGitDir })
    writeFileSync(join(testGitDir, 'untracked.txt'), 'untracked')

    const api = sourceScript('./utils/detection.sh')('repo_is_dirty')(testGitDir)
    expect(api).toBeSuccessful()
  })
})
```

---

### 2. `is_monorepo()` depends on THIS repo's structure (lines 597-618)

**Problem**: Tests assume the test repo has `pnpm-workspace.yaml`:

```typescript
it('should return 0 for this repo (has pnpm-workspace.yaml)', () => {
  const api = sourceScript('./utils/detection.sh')('is_monorepo')(process.cwd())
  expect(api).toBeSuccessful()
})
```

**Why this matters**: If someone forks or clones this repo and modifies the workspace structure, tests fail for unrelated reasons.

**Recommended fix**: Create test fixtures:

```typescript
it('should return 0 when pnpm-workspace.yaml exists', () => {
  const testProjectDir = join(testDir, 'mono-project')
  mkdirSync(testProjectDir, { recursive: true })
  execSync('git init', { cwd: testProjectDir })
  writeFileSync(join(testProjectDir, 'pnpm-workspace.yaml'), 'packages:\n  - "packages/*"')

  const api = sourceScript('./utils/detection.sh')('is_monorepo')(testProjectDir)
  expect(api).toBeSuccessful()
})

it('should return 0 when lerna.json exists', () => {
  const testProjectDir = join(testDir, 'lerna-project')
  mkdirSync(testProjectDir, { recursive: true })
  execSync('git init', { cwd: testProjectDir })
  writeFileSync(join(testProjectDir, 'lerna.json'), '{}')

  const api = sourceScript('./utils/detection.sh')('is_monorepo')(testProjectDir)
  expect(api).toBeSuccessful()
})

it('should return 0 when package.json has workspaces field', () => {
  const testProjectDir = join(testDir, 'npm-workspace')
  mkdirSync(testProjectDir, { recursive: true })
  execSync('git init', { cwd: testProjectDir })
  writeFileSync(join(testProjectDir, 'package.json'), '{"workspaces": ["packages/*"]}')

  const api = sourceScript('./utils/detection.sh')('is_monorepo')(testProjectDir)
  expect(api).toBeSuccessful()
})
```

---

### 3. `in_package_json()` depends on THIS repo's package.json (lines 489-505)

**Problem**:
```typescript
it('should return 0 when string exists in package.json', () => {
  // This repo has a package.json with "vitest" in it
  const api = sourceScript('./utils/detection.sh')('in_package_json')('vitest')
  expect(api).toBeSuccessful()
})
```

**Recommended fix**: Create a test package.json in the test directory and modify the function call to work with a specific path, OR use the test directory pattern.

---

### 4. `looks_like_js_project()` and similar tests (lines 676-715)

**Problem**: Tests depend on CWD being a JS project:

```typescript
it('should return 0 for this repo (has package.json)', () => {
  const api = sourceScript('./utils/detection.sh')('looks_like_js_project')()
  expect(api).toBeSuccessful()
})
```

**Why this matters**: These functions use CWD internally, so they can't be directed to test fixtures without modification. The test only validates "it works here" not "it works correctly."

**Recommended fix**: Either:
1. Modify the functions to accept an optional path parameter
2. Use `runInShell()` with `cwd` option to run from a test directory
3. Create a wrapper that changes CWD temporarily

---

## Suggested Improvements

### 5. Cross-shell tests should handle missing shells gracefully

The cross-shell tests properly check `isShellAvailable('zsh')`, which is good. However, consider adding skip annotations:

```typescript
it.skipIf(!isShellAvailable('zsh'))('should find executables in zsh', () => {
  // test code
})
```

This provides clearer test output vs silent passes.

---

### 6. `uv` installation tests depend on user's actual installation (lines 312-390)

**Problem**:
```typescript
it('should find uv when PATH includes ~/.local/bin (zsh specific)', function() {
  // ...
  if (existsSync(join(process.env.HOME || '', '.local/bin/uv'))) {
    expect(result.code).toBe(0)
    expect(result.stdout).toContain('FOUND')
  }
})
```

**Issue**: This test only runs if `uv` is actually installed. This is a form of "works on my machine" testing.

**Recommended approach**: Mock the binary existence by creating a dummy executable in a temp directory:

```typescript
it('should find command when binary exists in PATH', () => {
  const mockBinDir = join(testDir, '.local/bin')
  mkdirSync(mockBinDir, { recursive: true })
  writeFileSync(join(mockBinDir, 'mock-cmd'), '#!/bin/bash\necho "mock"')
  chmodSync(join(mockBinDir, 'mock-cmd'), '755')

  const result = runInShell('zsh', `
    export PATH="${mockBinDir}:$PATH"
    source ./utils/detection.sh
    has_command mock-cmd
  `)
  expect(result.code).toBe(0)
})
```

---

### 7. OS-specific detection tests are inherently platform-dependent (os.test.ts)

The `os.test.ts` tests are a good example of handling this correctly - they just verify the function exists and returns a valid exit code, without asserting WHICH OS is detected. This pattern should be followed elsewhere.

---

### 8. Container detection tests can't be validated outside containers (lines 81-111)

Tests like `is_docker()`, `is_lxc()`, `is_vm()` can only be fully tested inside those environments. The current approach of just checking for valid exit codes is reasonable, but consider adding:

```typescript
describe.skipIf(process.env.CI && !process.env.DOCKER_ENV)('container-specific tests', () => {
  // Tests that need to run inside containers
})
```

---

## Nits

### 9. Test file creates temp directory inside tests/ (line 7)

```typescript
const testDir = join(process.cwd(), 'tests', '.tmp-detection-test')
```

Consider using `os.tmpdir()` or a dedicated temp directory outside the source tree to avoid potential gitignore issues or accidental commits.

---

### 10. Inconsistent error message expectations

Some tests use `.toFail()` without specifying an exit code, while the underlying functions may have specific codes for different error conditions. Consider being more explicit:

```typescript
expect(api).toFail(1) // Specific exit code expected
```

---

## Positive Observations

### Good: Cross-shell test infrastructure

The `runInShell()`, `runInBothShells()`, and `isShellAvailable()` helpers in `shell-runner.ts` are well-designed and enable proper cross-shell testing.

### Good: Install mocking infrastructure

The `install.test.ts` file shows excellent use of mocking for external dependencies. The `runWithMocks()` pattern should be adapted for git operations testing.

### Good: Proper cleanup in beforeEach/afterEach

The test file properly creates and cleans up test directories, preventing pollution between tests.

### Good: Custom Vitest matchers

The `.toBeSuccessful()`, `.toFail()`, `.toReturn()` matchers make tests readable and intention-clear.

---

## Summary of Required Changes

| Test Block | Issue | Priority | Status |
|------------|-------|----------|--------|
| `repo_is_dirty()` | Depends on actual git state | **Critical** | **FIXED** |
| `is_monorepo()` | Depends on repo structure | **High** | **FIXED** |
| `in_package_json()` | Depends on repo's package.json | **High** | **FIXED** |
| `has_package_json()` | Depends on repo structure | **High** | **FIXED** |
| `is_git_repo()` | Depends on repo structure | **High** | **FIXED** |
| `repo_root()` | Depends on repo structure | **High** | **FIXED** |
| `has_typescript_files()` | Depends on repo structure | **High** | **FIXED** |
| `looks_like_*_project()` | Uses CWD directly | **Medium** | **FIXED** |
| `uv` PATH tests | Depends on user's installation | **Medium** | Left as-is (conditional) |

---

## Fixes Applied (2025-12-01)

### New Helper Functions Added

```typescript
/** Project root for absolute path references */
const PROJECT_ROOT = process.cwd()

function initGitRepo(dir: string): void { ... }
function commitFile(dir: string, filename: string, content: string, message: string): void { ... }
function runInTestDir(shell: 'bash' | 'zsh', testDir: string, script: string) { ... }
```

### Key Changes

1. **Isolated Git Repos**: Tests like `repo_is_dirty()`, `is_git_repo()`, `repo_root()` now create their own git repos in the test directory

2. **Use `/tmp` for Non-Git Tests**: Tests that need to verify behavior outside a git repo now use `/tmp` instead of subdirectories within the main repo (which are still part of the git tree)

3. **`runInTestDir()` Helper**: New helper function sources scripts from `PROJECT_ROOT` while running in a test directory, fixing the "command not found" (exit 127) errors

4. **Proper Cleanup**: Tests using `/tmp` directories include try/finally blocks to ensure cleanup

### Test Results

All 98 tests in `detection.test.ts` now pass, and the full suite (566 tests) passes without regressions.

---

## Remaining Recommendations

1. **Medium-term**: Add mock binary creation helpers for PATH-dependent tests (uv tests)
2. **Documentation**: Consider adding notes in CLAUDE.md about these test fixture patterns
