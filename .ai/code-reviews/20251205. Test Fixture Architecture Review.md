# Test Fixture Architecture Review

**Date:** 2025-12-05
**Scope:** Tests fixtures in `tests/fixtures/` and `tests/fixtures/generate-fixtures.ts`
**Files Reviewed:**
- `tests/fixtures/generate-fixtures.ts`
- `tests/unit/lang-js.test.ts`
- `tests/unit/lang-py.test.ts`
- `tests/unit/lang-rs.test.ts`

---

## Executive Summary

The fixture system is well-structured with a clear separation between static fixtures (193 directories, ~850KB total) and dynamic git-based fixtures (13 total). The `generate-fixtures.ts` script served its purpose but should be retained with modifications. The git fixture approach is sound but has room for consolidation.

---

## Question 1: Are the Fixture Quantities Appropriate?

### Analysis

| Category | Static Fixtures | Git Fixtures | Total |
|----------|----------------|--------------|-------|
| lang-js  | 47             | 3            | 50    |
| lang-py  | 83             | 5            | 88    |
| lang-rs  | 48             | 5            | 53    |
| **Total** | **178**       | **13**       | **191** |

**Disk Space:** ~850KB total - negligible.

### Findings

**Most fixtures are used exactly once.** Grep analysis shows only ~20 fixtures are reused across multiple tests, while the remaining 170+ are single-use.

**However, this is intentional and correct.** Each fixture represents a *distinct test scenario*. Examining the fixture contents reveals they test meaningful edge cases:

```
pkgs-in-deps:       {"dependencies":{"lodash":"^4.0.0","express":"^4.0.0"}}
pkgs-in-devdeps:    {"devDependencies":{"vitest":"^1.0.0","typescript":"^5.0.0"}}
pkgs-in-peerdeps:   {"peerDependencies":{"react":"^18.0.0","react-dom":"^18.0.0"}}
```

These test three distinct code paths in `packages_not_installed()`.

### Opportunities for Consolidation

While the current count is justifiable, there are **moderate consolidation opportunities** (~15-20 fixtures):

1. **Duplicate "no-arg" fixtures**: `dep-no-arg`, `dev-dep-no-arg`, `peer-dep-no-arg`, `build-dep-no-arg`, etc. share nearly identical structures (`{"name": "test"}`). These could be consolidated into a single `minimal-package` fixture reused across tests.

2. **Empty project variants**: `pyproject-empty`, `pkg-json-empty`, `cargo-empty`, `requirements-empty` all exist to test "file not found" scenarios. A single `empty-project` fixture with just a `readme.txt` could suffice.

3. **-none variants**: `linter-dep-none`, `linter-config-none`, `formatter-dep-none`, `formatter-config-none` often have the same structure. Could consolidate.

### Recommendation

**Keep the current quantity.** The benefits outweigh the costs:

- **Readability:** Test names like `dirs['has-dep-inline']` are immediately understandable
- **Isolation:** Each test scenario is self-contained; changing one fixture won't break unrelated tests
- **Debugging:** When a test fails, you can inspect exactly what files it expects
- **Disk space:** 850KB is trivial

**Optional minor consolidation:** If desired, consolidate the ~15 "minimal/empty/no-arg" fixtures into 3-4 shared fixtures. This would save minimal space but add slight cognitive overhead.

---

## Question 2: Should `generate-fixtures.ts` Be Deleted?

### Analysis

The script has:
- **Purpose completed:** Successfully converted dynamic fixtures to static
- **No active references:** Not invoked in CI, not mentioned in docs
- **Self-documenting value:** Contains the authoritative definition of fixture structures

### Recommendation

**Keep but repurpose.** The script serves as valuable documentation and could be useful for:

1. **Regenerating fixtures** if they become corrupted or need updates
2. **Adding new fixtures** with consistent structure
3. **Understanding fixture intent** - the TypeScript types (`FileFixture`, `GitFixture`) document the schema

### Suggested Changes

Add a header comment clarifying its role:

```typescript
/**
 * Fixture Generator & Documentation
 *
 * This script defines the canonical fixture structures for lang-js, lang-py, and lang-rs tests.
 *
 * Usage:
 *   npx tsx tests/fixtures/generate-fixtures.ts
 *
 * When to run:
 *   - After adding new fixture definitions to regenerate the fixture directories
 *   - To verify fixture structure matches definitions
 *
 * Note: Git-based fixtures are skipped; they must be created dynamically in tests
 * because they require actual git repository initialization.
 */
```

Also consider adding a `--verify` mode that checks existing fixtures match definitions without overwriting.

---

## Question 3: Better Approach for Git Fixtures?

### Current Approach

Each test file has:
1. A `GIT_FIXTURES` object defining the fixtures
2. `beforeAll()` that creates temp directories, runs `git init`, commits files
3. `afterAll()` that removes temp directories

```typescript
const GIT_FIXTURES: Record<string, GitFixture> = {
  'pkg-mgr-subdir-test': {
    subdirs: ['packages/app'],
    files: { 'package.json': '...', 'pnpm-lock.yaml': '...' },
    commits: [{ file: 'package.json', content: '...', message: 'init' }]
  }
}
```

### Assessment

**The current approach is fundamentally sound.** Git fixtures must be dynamic because:
- They test behavior that depends on `.git/` directory presence
- The shell functions use `git rev-parse --show-toplevel` to find repo root
- Static fixtures can't include `.git/` (it would conflict with the main repo)

### Optimization Opportunities

#### 1. Shared Git Fixture Utility (Low Effort, High Value)

Extract the common setup/teardown logic into a shared helper:

```typescript
// tests/helpers/git-fixtures.ts
export interface GitFixtureDef {
  subdirs?: string[]
  files: Record<string, string>
  commits: Array<{ file: string; content: string; message: string }>
}

export class GitFixtureManager {
  private tempDir: string
  private fixtures: Map<string, string> = new Map()

  constructor(private baseName: string) {
    this.tempDir = join(process.cwd(), 'tests', `.tmp-${baseName}`)
  }

  setup(definitions: Record<string, GitFixtureDef>): Record<string, string> {
    // Clean up any previous run
    if (existsSync(this.tempDir)) {
      rmSync(this.tempDir, { recursive: true })
    }
    mkdirSync(this.tempDir, { recursive: true })

    const dirs: Record<string, string> = {}
    for (const [name, def] of Object.entries(definitions)) {
      dirs[name] = this.createGitFixture(name, def)
    }
    return dirs
  }

  teardown(): void {
    if (existsSync(this.tempDir)) {
      rmSync(this.tempDir, { recursive: true })
    }
  }

  private createGitFixture(name: string, def: GitFixtureDef): string {
    // ... implementation
  }
}

// Usage in test file:
const gitManager = new GitFixtureManager('lang-js-git')
const gitDirs = gitManager.setup(GIT_FIXTURES)
// In beforeAll: merge into dirs
// In afterAll: gitManager.teardown()
```

#### 2. Consider "Template Repos" (Medium Effort)

Instead of creating fixtures from scratch each run, maintain them as `.git-template/` directories:

```
tests/fixtures/lang-js/.git-template/pkg-mgr-subdir-test/
  .git.tar  # Compressed git repo
  package.json
  pnpm-lock.yaml
  packages/app/
```

During `beforeAll()`, extract the tarball to a temp location. This would:
- Reduce test setup time (no `git init`, `git add`, `git commit`)
- Allow more complex git histories if needed
- Still keep `.git` out of main repo version control

**Tradeoff:** More complex maintenance, harder to update fixtures.

#### 3. Consolidate Git Fixture Definitions (Low Effort)

Several git fixtures are similar across test files. For example, all three test files have variants of:
- "prefer-cwd" (root has file, subdir has file, test runs from subdir)
- "repo-root" (root has file, test runs from subdir without the file)

These could be defined once in a shared module:

```typescript
// tests/fixtures/git-fixture-defs.ts
export const COMMON_GIT_PATTERNS = {
  preferCwd: (rootFile: string, subdirFile: string, subdir: string) => ({
    subdirs: [subdir],
    files: {
      [rootFile]: '...',
      [`${subdir}/${rootFile}`]: '...'
    },
    commits: [{ file: rootFile, content: '...', message: 'init' }]
  })
}
```

### Recommendation

**Implement Option 1** (shared GitFixtureManager) and **Option 3** (consolidated definitions). Together they would:
- Reduce ~150 lines of duplicated setup/teardown code across 3 test files
- Make git fixture management consistent
- Make it easier to add new git-based tests

**Skip Option 2** (template repos) unless test setup time becomes a measurable problem. The current approach takes <1 second and is simpler to maintain.

---

## Summary of Recommendations

### Must Fix
*None* - the current implementation is sound.

### Suggested Improvements

1. **Keep `generate-fixtures.ts`** but add documentation header explaining its role
2. **Extract GitFixtureManager** utility to reduce code duplication
3. **Consolidate git fixture definitions** across test files

### Positive Observations

- Clear separation between static and dynamic fixtures
- Self-documenting fixture names (e.g., `has-dep-inline`, `linter-config-ruff-pyproject`)
- Proper cleanup in `afterAll()` hooks
- Good use of TypeScript interfaces for fixture definitions
- Concurrent test execution (`{ concurrent: true }`) with isolated fixtures

### Nits

- The `commitFile()` helper in test files is defined but not used - consider removing
- Inconsistent escaping: some fixtures use `\\n` in TS strings, others use template literals with actual newlines

---

## Appendix: Fixture Statistics

```
Static Fixtures by Language:
  lang-py: 83 fixtures (408KB)
  lang-rs: 48 fixtures (220KB)
  lang-js: 47 fixtures (224KB)

Git Fixtures by Language:
  lang-py: 5 fixtures
  lang-rs: 5 fixtures
  lang-js: 3 fixtures

Most Reused Fixtures (used 2+ times):
  dep-no-arg: 3 uses
  pkgs-*: 2 uses each (many variants)
  no-*: 2 uses each (many variants)
```
