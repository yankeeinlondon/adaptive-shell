#!/usr/bin/env bash



if [ -z "${ADAPTIVE_SHELL}" ] || [[ "${ADAPTIVE_SHELL}" == "" ]]; then
    UTILS="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    if [[ "${UTILS}" == *"/utils" ]];then
        ROOT="${UTILS%"/utils"}"
    else
        ROOT="$UTILS"
    fi
else
    ROOT="${ADAPTIVE_SHELL}"
    UTILS="${ROOT}/utils"
fi



# use "dust" over base "du" if available
function du() {
    source "${UTILS}/logging.sh"
    source "${UTILS}/detection.sh"

    if has_command "dust"; then
        dust -X ".git" -X "node_modules" "$@"
        logc ""
        logc "{{DIM}}- excluded {{BLUE}}.git{{RESET}}{{DIM}} and {{BLUE}}node_modules{{RESET}}{{DIM}} directory from results{{RESET}}"
        logc "{{DIM}}- use {{GREEN}}{{BOLD}}dust{{RESET}}{{DIM}} to not exclude{{RESET}}"
    else
        if [ -z "$*" ]; then
            $(which du) "."
        else
            $(which du) "$*"
        fi
    fi
    remove_colors
}

# h <filter>
#
# history convenience utility
function h () {
    source "${UTILS}/logging.sh"
    source "${UTILS}/detection.sh"

    local -r filter_by="${1:-}"
    local numeric_re='^[0-9]+$'

    if [[ ${filter_by} =~ ${numeric_re} ]]; then
        logc "{{BOLD}}History{{RESET}} ({{ITALIC}}last ${filter_by}{{RESET}}):\n"
        if is_zsh; then
            builtin fc -l -- "-${filter_by}"
        elif is_bash; then
            builtin history "${filter_by}"
        else
            history "${filter_by}"
        fi
    elif [[ -z ${filter_by} ]]; then
        logc "{{BOLD}}History{{RESET}} ({{ITALIC}}all{{RESET}}):\n"
        if is_zsh; then
            builtin fc -l 1
        elif is_bash; then
            builtin history
        else
            history
        fi
    else
        logc "{{BOLD}}History{{RESET}} ({{ITALIC}}filtered by '${filter_by}'{{RESET}}):\n"
        local -a history_cmd
        if is_zsh; then
            history_cmd=(builtin fc -l 1)
        elif is_bash; then
            history_cmd=(builtin history)
        else
            history_cmd=(history)
        fi
        if has_command "rg"; then
            "${history_cmd[@]}" | rg -- "${filter_by}"
        else
            "${history_cmd[@]}" | command grep -- "${filter_by}"
        fi
    fi

}

function init() {
    bash "${ROOT}/programs/initialize.sh"
}

function installed() {
    # shellcheck source="./utils/install.sh"
    source "${UTILS}/install.sh"

    show_installed "$@"
}


function vitesse() {
    if [ -z "$1" ]; then
        logc "Syntax: ${BOLD}vitesse${NO_BOLD} ${ITALIC}\${1}${NO_ITALIC}, ${DIM}where ${NO_DIM}${ITALIC}\${1}${NO_ITALIC} ${DIM}indicates the directory to install to  ${NO_DIM}\n"
        return
    fi

    if ! has_command "node"; then
        if confirm "The host system does not have NodeJS installed; install now?"; then
            install_node
        else
            logc "We need node -- ((ITALIC}}and {{BOLD}}npx{{RESET}} -- to pull down the vitesse starter template. Exiting."
            return 1
        fi
    fi

    if ! has_command "pnpm"; then
        if confirm "The Vitesse starter template expect {{BOLD}}{{BLUE}}pnpm{{RESET}} to be used as the package manager but this isn't install on this host doesn't have it installed. Install now?"; then
            install_pnpm
        fi
    fi

    npx degit antfu/vitesse "$1" --force
}


function vitesse_ext() {
  if [ -z "$1" ]; then
    logc "Syntax: ${BOLD}vitesse-ext${NO_BOLD} ${ITALIC}\${1}${NO_ITALIC}, ${DIM}where ${NO_DIM}${ITALIC}\${1}${NO_ITALIC} ${DIM}indicates the directory to install to  ${NO_DIM}\n"
    return
  fi

  npx degit antfu/vitesse-webext "$1" --force
}


function gitignore() {
    source "${UTILS}/logging.sh"
    source "${UTILS}/color.sh"

  if [ ! -f "./.gitignore" ]; then
    logc "- creating {{BLUE}}.gitignore{{RESET}} file"
    logc ""
    cat <<'EOF' > "./.gitignore"
# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
**/trace/*.json
# Runtime data
*.pid
*.seed
*.pid.lock
# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov
# Coverage directory used by tools like istanbul
coverage
# nyc test coverage
.nyc_output
# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)
.grunt
# Bower dependency directory (https://bower.io/)
bower_components
# node-waf configuration
.lock-wscript
# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release
# Dependency directories
node_modules/
jspm_packages/
# Optional npm cache directory
.npm
# Optional eslint cache
.eslintcache
# Optional REPL history
.node_repl_history
# Output of 'npm pack'
*.tgz
# Yarn Integrity file
.yarn-integrity
# dotenv environment variables file
.env
# next.js build output
.next
# OS X temporary files
.DS_Store
# Transpiled Destinations
**/dist/
**/.presite
frontend/.vite-ssg-dist/**
/functions
# for simple TODOs
/todo.md

# Local Netlify folder
.netlify

.tsbuildinfo
trace/*
.trace/*
EOF
  else
    logc "- the ${BLUE}.gitignore${RESET} file already exists, ${ITALIC}skipping${RESET}"
  fi
}



# unset login_message

# net()
#
# Proxies the `network_interfaces()` function through as a
# command for the interactive console.
function net() {
    local -ra params=( "$@" )
    source "${UTILS}/detection.sh"
    source "${UTILS}/cli.sh"
    source "${UTILS}/network.sh"
    local -r file="${UTILS}/network.sh"

    logc "{{BOLD}}{{YELLOW}}Network Interfaces"
    list_network_interfaces

    logc "\n{{BOLD}}{{YELLOW}}TCP/IP Addresses"
    bash "${file}" "network_interfaces" "${params[@]}"
    logc "\n{{BOLD}}{{YELLOW}}Network Default Routes"
    bash "${file}" "get_routes" "${params[@]}"
    if ! has_cli_switch params "-6"; then
        logc "\n{{DIM}}{{ITALIC}}- use {{BOLD}}{{GREEN}}-6{{RESET}}{{DIM}}{{ITALIC}} to get IPv6 information too"
    fi
}

function track() {
    local -r file="${ROOT}/track.sh"
    local -ra params=( "$@" )

    bash "${file}" "${params[@]}"
}


# about()
#
# information about aliases, functions, binary
# paths, etc.
function about() {
    local -r file="${REPORTS}/about.sh"

    bash "${file}" "report_about"
}

function sys() {
    local -r file="${REPORTS}/sys.sh"

    bash "${file}" "report_sys"
}

if has_command "yazi"; then
    function y() {
        export EDITOR="nvim"
        local -r tmp="$(mktemp -t "yazi-cwd.XXXXXX")" cwd
        yazi "$@" --cwd-file="$tmp"
        if cwd="$(command cat -- "$tmp")" && [ -n "$cwd" ] && [ "$cwd" != "$PWD" ]; then
            builtin cd -- "$cwd" || exit 1
        fi
        rm -f -- "$tmp"
    }
else
    function y() {
        logc ""
        logc "the ${BOLD}${BLUE}Yazi${RESET} CLI file explorer is not installed"
        logc "> https://yazi-rs.github.io/docs/installation"
        logc ""
    }
fi

function upgrade() {
    # shellcheck source="./utils/interactive.sh"
    source "${UTILS}/interactive.sh"
    # shellcheck source="./utils/install.sh"
    source "${UTILS}/install.sh"

    logc "\n{{BOLD}}{{GREEN}}upgrade{{RESET}} will update all package managers installed on the system. This would include the OS's primary package manager as well package managers like gem,npm, pip, and uv."
    if confirm "Continue?"; then
        update_packages
        upgrade_packages
    else
        logc "\nOk.\n"
    fi
}

if has_function is_pve_host && { is_pve_host || is_pve_container || is_pve_aware; }; then
    function nodes() {
        source "${UTILS}/proxmox-utils.sh"
        source "${UTILS}/proxmox-api.sh"
        logc "$(get_pve_nodes)"
    }
fi

if ! has_command "uv"; then
    function uv() {
        logc "{{BOLD}}{{BLUE}}uv{{RESET}} [{{DIM}}https://docs.astral.sh/uv{{RESET}}] is not currently installed on this system."
        # shellcheck source="./utils/interactive.sh"
        source "${UTILS}/interactive.sh"
        if confirm "Install now?"; then
            # shellcheck source="./utils/install.sh"
            source "${UTILS}/install.sh"
            install_uv && ( unset -f uv )
        fi
    }
fi

if ! has_command "cargo"; then
    function cargo() {
        logc "{{BOLD}}{{BLUE}}Rust{{RESET}} -- {{ITALIC}}and therefore {{BOLD}}cargo{{RESET}} -- are not installed on this system."
        # shellcheck source="./utils/interactive.sh"
        source "${UTILS}/interactive.sh"
        if confirm "Install now?"; then
            # shellcheck source="./utils/install.sh"
            source "${UTILS}/install.sh"
            install_rust && ( unset -f cargo )
        fi
    }
fi

if ! has_command "make"; then
    function make() {
        logc "The {{BOLD}}{{BLUE}}make{{RESET}} utility is not installed on this system."
        # shellcheck source="./utils/interactive.sh"
        source "${UTILS}/interactive.sh"
        if confirm "Install make and other build tools now?"; then
            # shellcheck source="./utils/install.sh"
            source "${UTILS}/install.sh"
            install_build_tools && ( unset -f make && unset -f cmake && unset -f gcc)
        fi
    }
fi

if ! has_command "cmake"; then
    function cmake() {
        logc "The {{BOLD}}{{BLUE}}cmake{{RESET}} utility is not installed on this system."
        # shellcheck source="./utils/interactive.sh"
        source "${UTILS}/interactive.sh"
        if confirm "Install cmake and other build tools now?"; then
            # shellcheck source="./utils/install.sh"
            source "${UTILS}/install.sh"
            install_build_tools && ( unset -f cmake && unset -f make && unset -f gcc)
        fi
    }
fi

if ! has_command "gcc"; then
    function gcc() {
        logc "The {{BOLD}}{{BLUE}}gcc{{RESET}} utility is not installed on this system."
        # shellcheck source="./utils/interactive.sh"
        source "${UTILS}/interactive.sh"
        if confirm "Install gcc and other build tools now?"; then
            # shellcheck source="./utils/install.sh"
            source "${UTILS}/install.sh"
            install_build_tools && ( unset -f cmake && unset -f make && unset -f gcc )
        fi
    }
fi

if ! has_command "claude"; then
    function claude() {
        logc "{{BOLD}}{{BLUE}}Claude Code{{RESET}} is not installed on this machine."
        if confirm "Install now?"; then
            if install_claude_code; then
                unset -f claude
                claude
            else
                logc "Ok.\n"
                return 0
            fi
        else
            logc "Ok.\n"
            return 1
        fi
    }
fi
